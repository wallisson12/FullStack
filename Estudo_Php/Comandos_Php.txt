**Comandos**

-->O comando echo ""; serve para imprimir algo na tela

    echo ""; 

--> Variaveis em php

    $Idade = 23;

--> O comando Gettype(Variavel), ele vai retornar o tipo da variavel passada como paramentro

--> O comando para fazer a concatenacao eh: .

    echo 'Minha idade eh: ' . $idade;

    obs: Outra maneira eh utilizando "" e $idade;

    echo "Minha idade eh: $idade"

--> Quebra de linha

    echo "teste\n"; ou echo 'teste' . PHP_EOL
    echo 'Outra linha sem pular';

--> Tab

    echo "teste \n";
    echo "\t Outra linha sem pular";

    obs: Sao exemplos de caracteres especiais

--> Operador ternario

    $variavel = $condicao ? $valorSeVerdadeiro : $valorSeFalso;

--> Estrutura de repeticao Switch e o match

    obs: O match faz a mesma coisa so que o switch, so que eh mais utilizado

--> Possui for e foreach

--> Possui o 'break' e 'continue'

    obs: o break, para a execucao, o continue, pula para a proxima interracao

--> A funcao count(), recebe um arry como paramentro, e retorna o seu tamanho

    $a = [1,2,3,4,5];
    echo count($a);

--> Arry associativo, voce pode passar chave valor, a chave serve como indice

    //Arry associativos
    //Par chave valor
    $conta1 = 
    [
        'Titular' => 'Wallisson1',
        'Saldo' => 1000
    ];

    $conta2 = 
    [
        'Titular' => 'Wallisson2',
        'Saldo' => 10000
    ];

    $conta3 = 
    [
        'Titular' => 'Wallisson3',
        'Saldo' => 10000
    ];

    //Para imprimir o valor assiciado a chave 'Titular'
    echo $conta1['Titular'] . PHP_EOL;
        

    $contaCorrente = [$conta1,$conta2,$conta3];

    foreach ($contaCorrente as $conta) 
    {
        echo $conta['Titular'] . PHP_EOL;
    }

    obs: O indice do arry so pode ser int ou string

--> Adcionando um elemento na ultima posicao do arry

    $arry[] = 20;    

    obs: Quando nao passamos nada no indice, ele vai adcionar na ultima posicao

--> Removendo elemento de um array

    unset($arry[2]);

--> Estrutura basica de uma funcao, os paramentros sempre com '$'

    function ShowNome($nome){}

    Obs: Posso especificar qual o tipo do dado do paramentro e o que ela retorna 

    function WithDraw(float $valor) : float
    {....}

--> Interpolacao, com tipo mais complexos, utilizamos {}

    "$cpf {$conta['titular']  {$conta['saldo']}}"

--> Incluindo arquivos externos

    include 'Nome Do Arquivo'; 

            ou

    require_once'Nome Do Arquivo'; //Se for essencial para o funcionamento e verifica se foi chamando mais de uma vez

--> O comando strtoupper(), permite deixar as letras em maiusculo

--> A clausura &, permite acessar o valor guardado na memoria, como 'c', acessando por referencia

--> O comando list(), faz com que adcione cada elemento do arry para uma variavel

    //O elemento da posicao 0 vai para variavel_1, o elemento da posicao 1 vai para a variavel_2 ...
    list($variavel_1,$variavel_2,$variavel_3) = array
    
    ou

    ['titular' => $titular, 'saldo' => $saldo] = $conta;


**Php Poo**

--> Para acessar pripriedades de um objeto, usamos '->'

    obs: Quando for acessar a propriedade, nao precisa colocar o '$'

--> var_dump($obj), mostra o objeto

--> O metodo arry_sum(), realiza a soma dos elementos do array

--> O construtor tem que possuir '__' 

--> Se quiser posso definir as propriedades no construtor

    construtor(private string $nome,....){...}

--> Possui o tipo readonly

--> Declaracao de enum

    enum Genero{   
        case Acao;
        case Comedia;
        case Terror;
        case Drama;
    }

    Genero $teste = Genero::Acao;

--> Para acessar elementos estaticos 'self::$MembroEstatico'

--> Para herdar de uma classe, 'extends'

--> Para referenciar o pai 'parent::'

--> Possui tambem 'override' e 'protected'

--> Possui classes abstratas, ou seja, so permite herdar dela, nao instanciar

--> Possui 'namespaces'

    obs: Para usar o namespace, usamos a palavra 'use' e o caminho do namespace

--> AutoLod, uma ferramenta para subistituir o 'required'

    obs: com spl_autoload_requister(function(string $nomeCompletoDaClasse){...});

         ex: //vai ser disparado assim quer eu tentar acessar uma classe
        //E vai retornar no paramentro da funcao o caminho onde ela esta

        spl_autoload_register(function (string $nomeCompletoDaClasse) {

            //Vai retornar o caminho do arquivo da classe que quero acessar
            //Vai fazer a troca para colocar 'src' da minha pasta e .php
            //É uma maneira dinamica de fazer o required

            $caminhoArquivo = str_replace('Alura\\Banco', 'src', $nomeCompletoDaClasse);
            $caminhoArquivo = str_replace('\\', DIRECTORY_SEPARATOR, $caminhoArquivo);
            $caminhoArquivo .= '.php';

             //Verificando se o caminho vai ser verdadeiro

            if (file_exists($caminhoArquivo)) {
                
                //Fazendo o required do caminho dinamicamente
                require_once $caminhoArquivo;
            }
        });

--> Quando voce possui um metodo abstrato na classe, a classe tem que ser abstrata

--> Ordem de namespace

    Proprio namespace

    AutoLoad

    Chamando os namespaces para usar as classes que preciso

--> Suporta interface, onde por padrao todos os metodos dele sao abstratos

    interface Autenticavel
    {
        public function podeAutenticar(string $senha): bool;
    }

    obs: Para uma classe implementar uma interface, 'NomeDaClasse implement NomeDaInterface'

--> O metodo __toString, eh chamado toda vez que usamos o objeto da classe como uma string

--> O metodo __get, eh chamado quando queremos chamar um atributo da classe, como se fosse um getter
    no entanto, ou nao existe, ou eh privado.

--> Uma maneira de impedir a heranca, 'final', permitido para classe e para metodo, impedindo a sobreescricao

--> 'Trait', uma forma de voce injetar codigo em uma classe, para usar uma Trait,
    usamos, 'use' NomeDaTrait, dentro da classe que voce quer utilizar ela

**Php com Composer e PDO**

--> O composer eh um gerenciador de dependencias, onde posso criar e utilizar varias bibliotecas

--> Na pasta onde possui o composer, utilizar esse comando: composer dump-autoload

--> O Pdo, é uma forma de fazer o acesso ao banco de dados, onde ele possui varios drives para poder se conectar ao banco
    obs: Orm, uma forma de voce se conectar ao banco e fazer consultas usando o php

        - Fazendo a conecao com o banco, passando a string de conecao

    ex:     $caminhoBanco = __DIR__ ."/banco.sqlite";
            $pdo = new PDO('sqlite:' . $caminhoBanco);

--> O comando, executa um comando sql e retorna o numero de linhas afetadas

    $pdo->exec('Comando sql');

--> O comando, faz uma query no banco trazendo infromacoes, o fecthAll, eh uma maneira como esses objetos sao mostrados
    existem varios tipos de fecthAll, passando como paramentro.
    
    $obj = $pdo->query('Selecao de dados');
    $obj->fetchALL();

--> Para buscar um unico resultado usamos, quando temos variaos dados, para nao estourar a memoria

    $obj = $pdo->query('Selecao de dados, com apenas um caso');
    $obj->fecth(PDO::fecth_Assoc);
    
--> Para fungir de determinados erros, e segurança, podemos antes de fazer a execucao, fazer a preparacao

    $sqlInsert = "insert into students (...) values (...)";

    //Fazendo a preparacao
    $statment = $pdo->prepare($sqlInsert);

    //Bind dos valores em cada paramentro do objeto, e como terceiro paramentro o tipo
    $statment->bindValue(1'Primeiro paramentro',$student->name());
    $statment->bindValue(2'Segundo parametro',$student->brithDate()->format('Y-m-d'));

    //Esecutando o comando, retorna true ou false
    $statment->execute();

--> Fazendo o mapeamento do autoload utilizando a psr-4
    obs:Mapeando o namespace para o src

        "autoload":{
            "psr-4": {
                "Alura\\BuscadorDeCursos\\": "src/"
            }
        }

  obs: Posso utilizar o 'classmap' tambem, se estiver em um codigo legado e nao utilizaram o psr-4, './', diretorio atual
  obs2: Caso for uma funcao, posso utilizar o 'file'

-->

